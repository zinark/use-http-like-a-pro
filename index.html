<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profesyoneller Gibi HTTP İstekleri Gönderin</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f7f7f7;
        }

        .book {
            background: white;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        .title {
            text-align: center;
        }

        .chapter {
            margin-top: 20px;
        }

        .chapter-title {
            color: #333;
            font-size: 18px;
            font-weight: bold;
        }

        .chapter-content {
            margin-top: 10px;
        }

        pre {
            background-color: #eee;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>

<body>

    <div class="book">
        <div class="title">
            <h1>PROFESYONELLER GİBİ</h1>
            <h2>HTTP İSTEKLERİ GÖNDERİN</h2>
            <p>sadece 2 saatte -- bilmeniz gereken her şey</p>
        </div>

        <div class="chapter">
            <div class="chapter-title">1. Bölüm: cURL ile GET İsteği</div>
            <div class="chapter-content">
                <p>cURL ile GET isteği yapmak için aşağıdaki komutu kullanın:</p>
                <pre>curl http://ornek.com/api/veri</pre>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">2. Bölüm: cURL ile POST İsteği</div>
            <div class="chapter-content">
                <p>cURL ile POST isteği yapmak için aşağıdaki komutu kullanın:</p>
                <pre>curl -X POST -d "param1=deger1&param2=deger2" http://ornek.com/api/gonder</pre>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">3. Bölüm: Authorization Header Kullanımı</div>
            <div class="chapter-content">
                <p>HTTP isteğine Authorization header eklemek için aşağıdaki komutu kullanabilirsiniz:</p>
                <pre>curl -H "Authorization: Bearer SENIN_TOKENIN" http://ornek.com/api/gizli</pre>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">4. Bölüm: İstekleri Nasıl Kataloglarız</div>
            <div class="chapter-content">
                <p>HTTP isteklerini kataloglamak, API ile çalışırken düzeni sağlamak için önemlidir. Her isteğin
                    amacını, gönderilen verileri ve beklenen yanıtları açıkça belgelemek gerekir. Aşağıda, istekleri
                    kataloglama yöntemlerinden bahsedeceğiz:</p>

                <ul>
                    <li><strong>İstek Metodları:</strong> GET, POST, PUT, DELETE gibi farklı HTTP metodlarını ve
                        bunların ne zaman kullanılması gerektiğini belirtin.</li>
                    <li><strong>Endpoint Yapısı:</strong> Her bir API endpoint'i için bir standart yapınız olsun.
                        Örneğin, '/users' kullanıcı listesi, '/users/{id}' belirli bir kullanıcıya erişim için
                        kullanılabilir.</li>
                    <li><strong>Parametreler ve Gövde Verisi:</strong> İstek yaparken hangi parametrelerin ve gövde
                        verilerinin gerekli olduğunu belirtin.</li>
                    <li><strong>Yanıt ve Durum Kodları:</strong> API'nizin döndürebileceği yanıt tiplerini ve HTTP durum
                        kodlarını belirtin.</li>
                    <li><strong>Örnekler:</strong> Gerçek istek ve yanıtların örneklerini ekleyerek kullanıcıların ne
                        bekleyeceğini görsel olarak gösterin.</li>
                    <li><strong>Doğrulama ve Hata Kontrolü:</strong> Gönderilen verilerin doğruluğunu kontrol etme ve
                        olası hataları ele almanın yollarını açıklayın.</li>
                </ul>

                <p>İyi bir dokümantasyon ve açık kataloglama, API'nizin kullanımını kolaylaştırır ve hataları azaltır.
                </p>
            </div>
        </div>




        <div class="chapter">
            <div class="chapter-title">5. Bölüm: HTTP Hata Kodları</div>
            <div class="chapter-content">
                <p>HTTP hata kodları, sunucunun gelen isteklere nasıl yanıt verdiğini tanımlar. Aşağıda yaygın HTTP hata
                    kodları ve anlamları listelenmiştir:</p>

                <ul>
                    <li><strong>200 OK:</strong> İstek başarılı oldu ve yanıt istenilen içeriği içeriyor.</li>
                    <li><strong>400 Bad Request:</strong> İstek hatalı veya yanlış yapılandırılmış ve sunucu tarafından
                        işlenemedi.</li>
                    <li><strong>401 Unauthorized:</strong> İstek yetkilendirme gerektiriyor ve ya yetkilendirme
                        başarısız oldu ya da sağlanmadı.</li>
                    <li><strong>403 Forbidden:</strong> Sunucu isteği anladı ancak onu yerine getirmeyi reddediyor.</li>
                    <li><strong>500 Internal Server Error:</strong> Sunucu beklenmeyen bir durumla karşılaştı ve isteği
                        yerine getiremedi.</li>
                    <li><strong>503 Service Unavailable:</strong> Sunucu geçici bir aşırı yük ya da bakım nedeniyle
                        isteği işleme alamıyor.</li>
                    <li><strong>520 Unknown Error:</strong> Bu genellikle Cloudflare tarafından kullanılan özel bir hata
                        kodudur ve sunucunun bir beklenmedik durumla karşılaştığını gösterir.</li>
                </ul>

                <p>Bu hata kodlarını anlamak ve uygun şekilde ele almak, kullanıcı deneyimini büyük ölçüde
                    iyileştirebilir.</p>
            </div>
        </div>



        <div class="chapter">
            <div class="chapter-title">6. Bölüm: İsteklerde Zaman Aşımı ve Yeniden Deneme Stratejileri</div>
            <div class="chapter-content">
                <p>Uygulama yaparken ağ isteklerinin zamanında ve güvenilir şekilde tamamlanması önemlidir. Ağ hataları
                    ve yavaş yanıtlar gibi durumlarda, istekleri yeniden denemek ve zaman aşımı sürelerini uygun şekilde
                    ayarlamak gerekir. İşte bazı yönergeler:</p>

                <h3>Timeout Süresi</h3>
                <p>Bir istek için belirlenen zaman aşımı süresi (timeout), sunucunun yanıt vermesi için beklenen
                    maksimum süredir. Bu süre aşıldığında, istek başarısız sayılır. Örnek cURL kullanımı:</p>
                <pre>curl -m 10 http://ornek.com/api/veri</pre>
                <p>Burada '-m 10', cURL'un 10 saniye bekleyeceğini ve ardından zaman aşımına uğrayacağını belirtir.</p>

                <h3>Yeniden Deneme Sayısı</h3>
                <p>Bir isteğin kaç defa yeniden denenmesi gerektiği, isteğin önemine ve beklenen yanıt süresine göre
                    değişebilir. Örnek cURL kullanımı:</p>
                <pre>curl --retry 5 http://ornek.com/api/veri</pre>
                <p>Burada '--retry 5', cURL'un isteği 5 kez yeniden deneyeceğini gösterir.</p>

                <h3>Yeniden Deneme Kriterleri</h3>
                <p>Yeniden deneme kararı alırken aşağıdaki durumlar göz önünde bulundurulmalıdır:</p>
                <ul>
                    <li><strong>Geçici Hatalar:</strong> 503 Service Unavailable gibi geçici sunucu hatalarında.</li>
                    <li><strong>Ağ Hataları:</strong> Zaman aşımı veya ağ kesintisi gibi durumlarda.</li>
                    <li><strong>Başarısızlık Oranları:</strong> İsteklerin başarısızlık oranı yüksekse, daha az yeniden
                        deneme yapılmalıdır.</li>
                </ul>

                <h3>Örnek cURL Yeniden Deneme Kullanımı</h3>
                <p>Yeniden deneme politikalarını cURL ile birleştirerek, belirli hatalar ve zaman aşımı durumlarında
                    otomatik yeniden deneme sağlayabilirsiniz:</p>
                <pre>curl --retry 5 --retry-delay 3 --retry-max-time 120 --retry-connrefused http://ornek.com/api/veri</pre>
                <p>Bu komut, bağlantı reddedilirse bile, 3 saniyelik gecikmelerle toplamda 120 saniye içinde maksimum 5
                    kez yeniden deneme yapılmasını sağlar.</p>
            </div>
        </div>


        <div class="chapter">
            <div class="chapter-title">7. Bölüm: Veri Önbelleğe Alma Stratejileri</div>
            <div class="chapter-content">
                <p>Önbelleğe alma, sık kullanılan verileri geçici olarak saklayarak sistem performansını iyileştiren bir
                    yöntemdir. Doğru verileri önbelleğe almak uygulamanızın hızını ve verimliliğini artırabilir. Ancak,
                    tüm veriler önbelleğe alınmamalıdır.</p>

                <h3>Önbelleğe Alınabilir Veriler</h3>
                <ul>
                    <li><strong>Statik İçerik:</strong> CSS dosyaları, JavaScript kitaplıkları ve medya dosyaları gibi
                        değişmeyen içerikler.</li>
                    <li><strong>Yavaş Değişen Dinamik İçerik:</strong> Kullanıcı profilleri veya katalog gibi nadiren
                        güncellenen veriler.</li>
                    <li><strong>API Yanıtları:</strong> Sıkça erişilen ancak nadiren değişen API sonuçları.</li>
                </ul>

                <h3>Önbelleğe Almamak Gereken Durumlar</h3>
                <ul>
                    <li><strong>Güvenlik Tokenleri:</strong> Oturum tokenleri gibi güvenlik açısından hassas ve kişiye
                        özel olan bilgiler önbelleğe alınmamalıdır.</li>
                    <li><strong>Çok Sık Değişen Veriler:</strong> Gerçek zamanlı borsa verileri veya sosyal medya
                        güncellemeleri gibi sürekli güncellenen bilgiler.</li>
                    <li><strong>Hassas Bilgiler:</strong> Kişisel veriler veya işlem geçmişi gibi hassas bilgilerin
                        önbelleğe alınması güvenlik riskleri taşır.</li>
                </ul>

                <p>Önbelleğe almanın temel amacı, tekrar eden veri taleplerinde performansı artırmak ve sunucu yükünü
                    azaltmaktır. Ancak, önbelleğe alınan verilerin güncelliğini korumak ve güvenlik standartlarına uymak
                    da önemlidir.</p>

                <h3>Önbelleğe Alma İle İlgili İpuçları</h3>
                <p>Önbelleğe alma süresi, 'Cache-Control' HTTP başlığı aracılığıyla kontrol edilir. Statik içerik için
                    uzun süreli, dinamik içerik için ise daha kısa süreli önbelleğe alma stratejileri uygulanabilir.</p>
                <pre>Cache-Control: public, max-age=31536000</pre>
                <p>Bu örnek, tarayıcıya ve ara sunuculara (proxy) belirtilen kaynağın 1 yıl boyunca önbelleğe
                    alınabileceğini bildirir.</p>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">8. Bölüm: HTTP Yanıtlarının Ayrıştırılması</div>
            <div class="chapter-content">
                <p>API'den alınan HTTP yanıtlarının doğru şekilde ayrıştırılması, hizmetin sağlıklı bir şekilde
                    kullanılabilmesi için kritik önem taşır. Durum kodlarına göre yanıtların nasıl işleneceğini aşağıda
                    bulabilirsiniz:</p>

                <h3>Başarılı Yanıtlar (200 Serisi)</h3>
                <p>Başarılı yanıtlar genellikle JSON formatındadır. Yanıtın bu formatı doğrulayın ve uygun bir JSON
                    parser kullanarak verileri işleyin:</p>
                <pre>
      // cURL komutu ile API'den veri talebi
      curl -X GET "http://ornek.com/api/veri" -H "accept: application/json"
      // Yanıtın başarılı olduğu durumda JSON ayrıştırma
      if (response.statusCode === 200) {
        let data = JSON.parse(response.body);
        // İşlem yap...
      }
    </pre>

                <h3>Kullanıcı Hataları (400 Serisi)</h3>
                <p>400'lü hatalar genellikle kullanıcı kaynaklı sorunları ifade eder ve hata detayları çoğu zaman JSON
                    formatında sağlanır. Bu durumda, hata mesajını ayrıştırarak kullanıcıya net bir geri bildirim
                    yapabilirsiniz:</p>
                <pre>
      // Kullanıcı kaynaklı hata durumunda JSON ayrıştırma
      if (response.statusCode >= 400 && response.statusCode < 500) {
        try {
          let errorDetails = JSON.parse(response.body);
          // Kullanıcıya hata ayrıntılarını göster...
        } catch (e) {
          // JSON ayrıştırma başarısız oldu, alternatif hata işleme...
        }
      }
    </pre>

                <h3>Sunucu Hataları (500 Serisi)</h3>
                <p>500'lü hatalar sunucu kaynaklıdır ve teknik sorunları işaret eder. Bu yanıtların formatı sabit
                    olmadığı için, sunucu hatası durumunda detayları loglama ihtiyacınız olabilir:</p>
                <pre>
      // Sunucu hatası durumunda işlem
      if (response.statusCode >= 500) {
        // Log kaydı yapın. Formatın JSON olup olmadığını kontrol edin...
        console.error('Sunucu hatası:', response.body);
        try {
          // Eğer yanıt JSON formatında ise ayrıştır...
          let errorInfo = JSON.parse(response.body);
          // İşlem yap...
        } catch (e) {
          // JSON ayrıştırma başarısız oldu, ham metin olarak loglama...
        }
      }
    </pre>

                <p>Yanıtları ayrıştırırken, her durum kodu için yanıtın formatının garantili olmadığını unutmayın. Yanıt
                    içeriğini doğru bir şekilde ayrıştırmak ve beklenmeyen durumlara hazırlıklı olmak için her zaman
                    yanıt tipini kontrol edin.</p>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">9. Bölüm: Atılan İsteklerin Otomasyonu</div>
            <div class="chapter-content">
                <p>Otomasyon, geliştirme süreçlerinde zamanı verimli kullanma, hata oranlarını düşürme ve maliyetleri
                    azaltma açısından büyük önem taşır. SpecFlow, Postman ve unit test framework'leri gibi araçlarla API
                    çağrıları otomatik hale getirilebilir. Bu bölümde, basit bir kullanıcı yönetim akışını otomatize
                    etmek için cURL ile atılabilecek sıralı istekleri inceleyeceğiz.</p>

                <h3>Otomasyon Senaryosu</h3>
                <p>Aşağıda, bir kullanıcı yönetim sürecini otomatize etmek için gerekli adımları ve karşılık gelen cURL
                    komutlarını bulacaksınız:</p>

                <ol>
                    <li><strong>Token Al:</strong> Kimlik doğrulama servisine istek atarak bir token alın.</li>
                    <pre>curl -X POST -d "username=ornekKullanici&password=ornekSifre" http://ornek.com/api/auth</pre>

                    <li><strong>Token ile Kullanıcı Listele:</strong> Alınan tokenı kullanarak kullanıcı listesi çekin.
                    </li>
                    <pre>curl -X GET http://ornek.com/api/users -H "Authorization: Bearer alinanToken"</pre>

                    <li><strong>Kullanıcı Ekle:</strong> Yeni bir kullanıcı ekleyin.</li>
                    <pre>curl -X POST -d "username=yeniKullanici&email=yeni@email.com" http://ornek.com/api/users -H "Authorization: Bearer alinanToken"</pre>

                    <li><strong>Kullanıcı Değiştir:</strong> Mevcut bir kullanıcının bilgilerini güncelleyin.</li>
                    <pre>curl -X PUT -d "username=guncelKullanici&email=guncel@email.com" http://ornek.com/api/users/1 -H "Authorization: Bearer alinanToken"</pre>

                    <li><strong>Kullanıcı Sil:</strong> Bir kullanıcıyı sistemden kaldırın.</li>
                    <pre>curl -X DELETE http://ornek.com/api/users/1 -H "Authorization: Bearer alinanToken"</pre>
                </ol>

                <p>Bu otomatik senaryo, bir dizi API çağrısının nasıl sıralanacağını ve birbirine bağlı işlemlerin nasıl
                    gerçekleştirileceğini gösterir. Otomasyon, bu tür süreçleri hızlandırır, hataları azaltır ve sürekli
                    entegrasyon/deployment (CI/CD) süreçlerindeki verimliliği artırır. Otomasyon aynı zamanda, manuel
                    test süreçlerinin yerine geçerek, geliştiricilerin ve QA ekiplerinin zamanlarını daha karmaşık ve
                    değerli görevlere ayırmalarını sağlar.</p>

                <p>Özellikle zamanın kritik olduğu durumlarda, otomasyon, süreçleri hızlandırmak ve pazarda ürünü daha
                    hızlı bir şekilde sunmak için değerlidir. Maliyetleri düşürme konusunda da, otomasyon, tekrar eden
                    işlemleri minimize ederek ve hataları erkenden tespit ederek uzun vadede tasarruf sağlar.</p>
            </div>
        </div>

        <div class="chapter">
            <div class="chapter-title">10. Bölüm: Swagger ve OpenAPI ile API Dokümantasyonu</div>
            <div class="chapter-content">
                <p>Swagger ve OpenAPI, API'lerinizi dokümante etmenin modern ve etkili yollarını sunar. Bu araçlar,
                    API'nizin potansiyelini maksimuma çıkarmak ve geliştiricilere entegrasyon için net bir rehberlik
                    sağlamak adına kullanılabilir.</p>

                <h3>Swagger / OpenAPI Nedir?</h3>
                <p>Swagger (OpenAPI), REST API'ler için bir açıklama formatıdır. API'nizin yeteneklerini ve kullanımını
                    açıklayan bir dökümantasyon oluşturmanızı sağlar. Swagger UI ise, bu dökümantasyonu interaktif bir
                    web sayfası haline getirir ve kullanıcıların API'yi test etmelerine olanak tanır.</p>

                <h3>Swagger Dökümantasyonundan Nasıl Yararlanılır?</h3>
                <p>Swagger dökümantasyonu, API'nizin özelliklerini keşfetmek ve test etmek için kullanışlı bir araçtır.
                    Bir API'nin Swagger dökümantasyonu, genellikle bir URL üzerinden erişilebilir. Örneğin:</p>
                <pre>http://ornek.com/api/swagger-ui.html</pre>
                <p>Bu URL'de, API'nizin tüm endpoint'leri, mümkün parametreler ve hata kodları hakkında bilgileri
                    bulabilirsiniz. Ayrıca, doğrudan web arayüzü üzerinden API istekleri göndererek yanıtları
                    görebilirsiniz.</p>

                <h3>Swagger Dökümantasyonunu Clientlara Entegre Etme</h3>
                <p>Swagger dökümantasyonu, genellikle bir JSON veya YAML dosyası olarak sunulur. Bu dosya, Postman,
                    JetBrains Rider veya diğer API client programlarına kolaylıkla import edilebilir. Böylece API'yi
                    daha rahat test etme ve entegre etme imkanı bulabilirsiniz.</p>
                <p>Örneğin, Postman ile bir Swagger dosyasını içe aktarmak için:</p>
                <ol>
                    <li>Postman uygulamasını açın.</li>
                    <li>'Import' düğmesine tıklayın.</li>
                    <li>Swagger dosyasının URL'sini yapıştırın veya dosyayı doğrudan yükleyin.</li>
                    <li>'Import' seçeneğine tıklayarak API'nizi Postman koleksiyonuna ekleyin.</li>
                </ol>
                <p>JetBrains Rider gibi bir IDE kullanıyorsanız, genellikle 'Tools' > 'HTTP Client' > 'Test RESTful Web
                    Service' seçeneğinden Swagger dökümantasyonunu yükleyebilir ve API isteklerinizi doğrudan IDE
                    üzerinden gönderebilirsiniz.</p>

                <p>Swagger / OpenAPI'nin gücü, API'lerinizi hızlı ve doğru bir şekilde kullanılabilir hale
                    getirmesindedir. Geliştirme süreçlerini hızlandırmanın ve hata riskini azaltmanın yanı sıra, dış
                    hizmetlerle entegrasyonu kolaylaştırır ve API'nizin kullanımını genişletir.</p>
            </div>
        </div>

    </div>

</body>

</html>
